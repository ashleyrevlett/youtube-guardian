// Caption/subtitle downloader using yt-dlp binary
import fs from 'fs';
import path from 'path';
import {fileURLToPath} from 'url';
import {spawn} from 'child_process';

const PROJECT_ROOT = path.join(path.dirname(fileURLToPath(import.meta.url)), '..', '..');
const CAPTIONS_DIR = path.join(PROJECT_ROOT, 'data', 'captions');

/**
 * Sleep utility for delays
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Download captions/subtitles for a video using yt-dlp
 * @param {string} videoId - YouTube video ID
 * @returns {Promise<{captionFiles: string[], language: string, type: string}>}
 */
async function downloadCaptions(videoId) {
  // Ensure captions directory exists
  if (!fs.existsSync(CAPTIONS_DIR)) {
    fs.mkdirSync(CAPTIONS_DIR, {recursive: true});
  }

  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const outputTemplate = path.join(CAPTIONS_DIR, `${videoId}.%(ext)s`);

  return new Promise((resolve, reject) => {
    // yt-dlp command to download subtitles only (no video)
    const args = [
      youtubeUrl,
      '--write-auto-subs',        // Download auto-generated captions
      '--write-subs',             // Download user-created subtitles (if available)
      '--sub-langs', 'en',        // English subtitles only
      '--sub-format', 'srt',      // SRT format (most compatible)
      '--skip-download',          // Don't download the video
      '-o', outputTemplate,       // Output filename template
      '--no-warnings',            // Suppress warnings
      '--quiet'                   // Minimal output
    ];

    const ytdlp = spawn('yt-dlp', args);

    let errorOutput = '';
    let stdOutput = '';

    // Capture stderr for errors
    ytdlp.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });

    // Capture stdout
    ytdlp.stdout.on('data', (data) => {
      stdOutput += data.toString();
    });

    ytdlp.on('close', (code) => {
      if (code === 0) {
        // Download successful, find the caption files
        const captionFiles = [];

        // Check for different possible caption file formats
        const possibleFiles = [
          `${videoId}.en.srt`,           // User-created English
          `${videoId}.en-US.srt`,        // User-created English (US)
          `${videoId}.en-GB.srt`,        // User-created English (GB)
          `${videoId}.en.en.srt`,        // Sometimes duplicated
          `${videoId}.en-orig.srt`       // Original language
        ];

        for (const filename of possibleFiles) {
          const filePath = path.join(CAPTIONS_DIR, filename);
          if (fs.existsSync(filePath)) {
            captionFiles.push(filePath);
          }
        }

        // Also check for auto-generated captions pattern
        const files = fs.readdirSync(CAPTIONS_DIR);
        const videoCaptions = files.filter(f =>
          f.startsWith(videoId) &&
          f.endsWith('.srt') &&
          !captionFiles.includes(path.join(CAPTIONS_DIR, f))
        );

        videoCaptions.forEach(f => {
          captionFiles.push(path.join(CAPTIONS_DIR, f));
        });

        if (captionFiles.length > 0) {
          // Determine if auto-generated or manual
          const isAutoGenerated = captionFiles[0].includes('-orig') ||
                                   !possibleFiles.slice(0, 3).some(f =>
                                     captionFiles.includes(path.join(CAPTIONS_DIR, f))
                                   );

          resolve({
            captionFiles,
            language: 'en',
            type: isAutoGenerated ? 'auto-generated' : 'manual'
          });
        } else {
          reject(new Error('No captions available for this video'));
        }
      } else {
        // Download failed
        const error = errorOutput.trim() || stdOutput.trim() || `yt-dlp exited with code ${code}`;

        // Check if error is due to no captions available
        if (error.includes('no subtitles') || error.includes('No subtitles')) {
          reject(new Error('No captions available for this video'));
        } else {
          reject(new Error(error));
        }
      }
    });

    ytdlp.on('error', (error) => {
      reject(new Error(`Failed to spawn yt-dlp: ${error.message}`));
    });
  });
}

/**
 * Check if captions are already downloaded for a video
 * @param {string} videoId - YouTube video ID
 * @returns {boolean}
 */
function areCaptionsDownloaded(videoId) {
  if (!fs.existsSync(CAPTIONS_DIR)) {
    return false;
  }

  const files = fs.readdirSync(CAPTIONS_DIR);
  return files.some(f => f.startsWith(videoId) && f.endsWith('.srt'));
}

/**
 * Get caption file path for a video
 * @param {string} videoId - YouTube video ID
 * @returns {string|null} Path to caption file or null if not found
 */
function getCaptionFile(videoId) {
  if (!fs.existsSync(CAPTIONS_DIR)) {
    return null;
  }

  const files = fs.readdirSync(CAPTIONS_DIR);
  const captionFile = files.find(f => f.startsWith(videoId) && f.endsWith('.srt'));

  return captionFile ? path.join(CAPTIONS_DIR, captionFile) : null;
}

/**
 * Read and parse caption file content
 * @param {string} videoId - YouTube video ID
 * @returns {string|null} Caption text content or null
 */
function readCaptionText(videoId) {
  const captionFile = getCaptionFile(videoId);

  if (!captionFile) {
    return null;
  }

  const content = fs.readFileSync(captionFile, 'utf-8');

  // Parse SRT format and extract just the text (remove timestamps and index numbers)
  const lines = content.split('\n');
  const textLines = [];

  for (const line of lines) {
    const trimmed = line.trim();
    // Skip empty lines, index numbers, and timestamp lines
    if (trimmed &&
        !trimmed.match(/^\d+$/) &&
        !trimmed.match(/^\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}$/)) {
      textLines.push(trimmed);
    }
  }

  return textLines.join(' ');
}

/**
 * Download captions for all videos with rate limiting
 * @param {string[]} videoIds - Array of YouTube video IDs
 * @returns {Promise<{success: number, failed: number, skipped: number, noCaptions: number}>}
 */
async function downloadAllCaptions(videoIds) {
  const results = {
    success: 0,
    failed: 0,
    skipped: 0,
    noCaptions: 0,
    errors: []
  };

  console.log(`\nDownloading captions for ${videoIds.length} videos using yt-dlp...\n`);

  const startTime = Date.now();

  for (let i = 0; i < videoIds.length; i++) {
    const videoId = videoIds[i];
    const progress = `[${i + 1}/${videoIds.length}]`;

    // Check if already downloaded
    if (areCaptionsDownloaded(videoId)) {
      console.log(`${progress} ⊘ ${videoId} - Captions already downloaded, skipping`);
      results.skipped++;
      continue;
    }

    try {
      console.log(`${progress} Downloading captions for ${videoId}...`);

      const {captionFiles, type} = await downloadCaptions(videoId);

      results.success++;
      console.log(`${progress} ✓ ${videoId} (${type}, ${captionFiles.length} file(s))`);

      // Small delay between downloads
      if (i + 1 < videoIds.length) {
        await sleep(500); // 0.5 second delay
      }

    } catch (error) {
      if (error.message.includes('No captions available')) {
        results.noCaptions++;
        console.log(`${progress} ○ ${videoId} - No captions available`);
      } else {
        results.failed++;
        console.log(`${progress} ✗ ${videoId} - ${error.message}`);
        results.errors.push({videoId, error: error.message});
      }
    }
  }

  const duration = ((Date.now() - startTime) / 1000).toFixed(1);

  console.log('\n' + '='.repeat(60));
  console.log('\nCaption Download Summary:');
  console.log(`  ✓ Downloaded: ${results.success} videos`);
  console.log(`  ⊘ Skipped: ${results.skipped} videos (already downloaded)`);
  console.log(`  ○ No captions: ${results.noCaptions} videos`);
  console.log(`  ✗ Failed: ${results.failed} videos`);
  console.log(`  ⏱  Total time: ${duration}s`);
  console.log();

  return results;
}

/**
 * Delete caption files for a specific video
 * @param {string} videoId - YouTube video ID
 * @returns {number} Count of deleted files
 */
function deleteCaptions(videoId) {
  if (!fs.existsSync(CAPTIONS_DIR)) {
    return 0;
  }

  const files = fs.readdirSync(CAPTIONS_DIR);
  const captionFiles = files.filter(f => f.startsWith(videoId) && f.endsWith('.srt'));

  for (const file of captionFiles) {
    fs.unlinkSync(path.join(CAPTIONS_DIR, file));
  }

  return captionFiles.length;
}

/**
 * Clean up all downloaded captions
 * @returns {number} Count of deleted files
 */
function cleanupAllCaptions() {
  if (!fs.existsSync(CAPTIONS_DIR)) {
    return 0;
  }

  const files = fs.readdirSync(CAPTIONS_DIR);
  const srtFiles = files.filter(f => f.endsWith('.srt'));

  for (const file of srtFiles) {
    fs.unlinkSync(path.join(CAPTIONS_DIR, file));
  }

  return srtFiles.length;
}

export {
  downloadCaptions,
  downloadAllCaptions,
  areCaptionsDownloaded,
  getCaptionFile,
  readCaptionText,
  deleteCaptions,
  cleanupAllCaptions,
  CAPTIONS_DIR
};
